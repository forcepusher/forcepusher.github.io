<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <title>Igromania</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: black;
    }
  </style>
</head>

<body>
  
  <script>
  (function(){
    const overlay = document.createElement('div');
    Object.assign(overlay.style, {
      position: 'fixed',
      right: '12px',
      top: '12px',
      zIndex: 999999,
      background: 'rgba(0,0,0,0.85)',
      color: '#fff',
      padding: '10px 14px',
      borderRadius: '8px',
      fontFamily: 'system-ui,Segoe UI,Roboto,Arial',
      fontSize: '13px',
      minWidth: '220px',
      maxWidth: '60vw',
      wordBreak: 'break-word',
      boxShadow: '0 6px 18px rgba(0,0,0,0.3)'
    });

    overlay.innerHTML = '<div style="font-weight:600;margin-bottom:6px">Input Monitor</div>' +
      '<div><strong>Keyboard:</strong> <span id="kp-keys">None</span></div>' +
      '<div><strong>Gamepads:</strong> <span id="kp-gpads">None</span></div>' +
      '<div style="margin-top:6px;font-size:12px;color:#ddd" id="kp-recent"></div>';
    document.body.appendChild(overlay);

    const keysEl = overlay.querySelector('#kp-keys');
    const gpadsEl = overlay.querySelector('#kp-gpads');
    const recentEl = overlay.querySelector('#kp-recent');

    const pressedKeys = new Map(); // key -> {key, code, keyCode}
    const recent = [];

    function noteRecent(s){
      recent.unshift((new Date()).toLocaleTimeString() + ' ' + s);
      if(recent.length>12) recent.pop();
      render();
    }

    function render(){
      if(pressedKeys.size){
        keysEl.textContent = Array.from(pressedKeys.values()).map(v => `${v.key} (${v.code || v.keyCode})`).join(' + ');
      } else keysEl.textContent = 'None';

      const gps = buildGamepadPressedDisplay();
      gpadsEl.textContent = gps || 'None';

      recentEl.textContent = recent.length ? 'Recent: ' + recent.join(' Â· ') : '';
    }

    window.addEventListener('keydown', (e) => {
      const name = e.key === ' ' ? 'Space' : e.key;
      pressedKeys.set(name + '|' + (e.code||e.keyCode), {key: name, code: e.code, keyCode: e.keyCode});
      noteRecent('keydown:' + name + ' code=' + (e.code||e.keyCode));
      render();
    });

    window.addEventListener('keyup', (e) => {
      const name = e.key === ' ' ? 'Space' : e.key;
      pressedKeys.delete(name + '|' + (e.code||e.keyCode));
      noteRecent('keyup:' + name + ' code=' + (e.code||e.keyCode));
      render();
    });

    // Input events (mobile/IME)
    document.addEventListener('input', (e) => {
      const text = e.data ?? '';
      if(text){
        noteRecent('input:' + text);
        // briefly show the character
        pressedKeys.set('input:' + text, {key: text, code: 'input'});
        render();
        setTimeout(()=>{ pressedKeys.delete('input:' + text); render(); }, 700);
      }
    }, true);

    // IME composition end
    document.addEventListener('compositionend', (e)=>{
      const text = e.data || '';
      if(text){
        noteRecent('composition:' + text);
        pressedKeys.set('composition:' + text, {key: text, code: 'composition'});
        render();
        setTimeout(()=>{ pressedKeys.delete('composition:' + text); render(); }, 900);
      }
    }, true);

    // Clear on blur/hidden
    window.addEventListener('blur', ()=>{ pressedKeys.clear(); noteRecent('blur'); render(); });
    document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ pressedKeys.clear(); noteRecent('hidden'); render(); }});

    // Click overlay to collapse/expand
    let collapsed = false;
    overlay.style.cursor = 'pointer';
    overlay.addEventListener('click', ()=>{
      collapsed = !collapsed;
      overlay.style.height = collapsed ? '30px' : '';
      overlay.style.overflow = collapsed ? 'hidden' : '';
      render();
    });

    // --- Gamepad / TV remote support ---
    const gpState = {}; // index -> {buttons: Set(indexes), id}

    function buildGamepadPressedDisplay(){
      const gp = navigator.getGamepads ? navigator.getGamepads() : [];
      const parts = [];
      for(let i=0;i<gp.length;i++){
        const g = gp[i];
        if(!g) continue;
        const pressed = [];
        for(let b=0;b<g.buttons.length;b++){
          if(g.buttons[b].pressed) pressed.push(buttonName(g,b));
        }
        if(pressed.length) parts.push(`${g.id.split('\n')[0]}: ${pressed.join(', ')}`);
      }
      return parts.join(' | ');
    }

    function buttonName(g, idx){
      // common mappings; remotes vary so include index fallback
      const map = {
        0:'Btn0',1:'Btn1',2:'Btn2',3:'Btn3',4:'L1',5:'R1',6:'L2',7:'R2',8:'Select',9:'Start',10:'LStick',11:'RStick',12:'Up',13:'Down',14:'Left',15:'Right',16:'Home',17:'Back'
      };
      if(idx in map) return map[idx];
      return 'B' + idx;
    }

    let gpPolling = false;
    function startGamepadPolling(){
      if(gpPolling) return; gpPolling = true;
      let lastPressed = {};
      function poll(){
        const gps = navigator.getGamepads ? navigator.getGamepads() : [];
        for(let i=0;i<gps.length;i++){
          const g = gps[i];
          if(!g) continue;
          const nowPressed = [];
          for(let b=0;b<g.buttons.length;b++) if(g.buttons[b].pressed) nowPressed.push(b);
          const key = g.index + '|' + g.id;
          const prev = lastPressed[key] || '';
          const curr = nowPressed.join(',');
          if(prev !== curr){
            lastPressed[key] = curr;
            if(nowPressed.length){
              noteRecent('gamepad['+g.index+']:' + (g.id.split('\n')[0]) + ' pressed ' + nowPressed.map(i=>buttonName(g,i)).join(','));
            } else {
              noteRecent('gamepad['+g.index+']:' + (g.id.split('\n')[0]) + ' released');
            }
          }
        }
        render();
        requestAnimationFrame(poll);
      }
      requestAnimationFrame(poll);
    }

    window.addEventListener('gamepadconnected',(e)=>{
      noteRecent('gamepadconnected:' + e.gamepad.id);
      startGamepadPolling();
    });
    window.addEventListener('gamepaddisconnected',(e)=>{
      noteRecent('gamepaddisconnected:' + e.gamepad.id);
      render();
    });

    try{ if(navigator.getGamepads && Array.from(navigator.getGamepads()).some(g=>g)) startGamepadPolling(); }catch(_){}

    const clog = (...a)=>{ try{ console.log.apply(console, ['[input-monitor]',...a]); }catch(e){} };
    window.addEventListener('keydown', (e)=> clog('keydown', e.key, e.code, e.keyCode));
    window.addEventListener('keyup', (e)=> clog('keyup', e.key, e.code, e.keyCode));

    render();
  })();
  </script>
</body>

</html>